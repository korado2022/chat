# Задание 1
# Каждое из слов «разработка», «сокет», «декоратор» представить в строковом формате и
# проверить тип и содержание соответствующих переменных. Затем с помощью
# онлайн-конвертера преобразовать строковые представление в формат Unicode и также
# проверить тип и содержимое переменных

# задаем переменные в строковом формате
word1 = 'разработка'
word2 = 'сокет'
word3 = 'декоратор'

# выводим содержимое и типы переменных
print(word1, type(word1))
print(word2, type(word2))
print(word3, type(word3))

# Результат выполнения команд:

# разработка <class 'str'>
# сокет <class 'str'>
# декоратор <class 'str'>

word1_u = '\u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0430'
word2_u = '\u0441\u043e\u043a\u0435\u0442'
word3_u = '\u0434\u0435\u043a\u043e\u0440\u0430\u0442\u043e\u0440'

print(word1_u, type(word1_u))
print(word2_u, type(word2_u))
print(word3_u, type(word3_u))

# Результат выполнения команд:
# разработка <class 'str'>
# сокет <class 'str'>
# декоратор <class 'str'>

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# Задание 2
# Каждое из слов «class», «function», «method» записать в байтовом типе без преобразования в
# последовательность кодов (не используя методы encode и decode) и определить тип,
# содержимое и длину соответствующих переменных

# задаем переменные в байтовом типе формате
word4 = b'class'
word5 = b'function'
word6 = b'method'

# выводим типы, содержимое и длину переменных
print(type(word4), word4, len(word4))
print(type(word5), word5, len(word5))
print(type(word6), word6, len(word6))

# Результат выполнения команд:

# <class 'bytes'> b'class' 5
# <class 'bytes'> b'function' 8
# <class 'bytes'> b'method' 6

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# Задание 3
# Определить, какие из слов «attribute», «класс», «функция», «type» невозможно записать в
# байтовом типе

# задаем переменные в байтовом типе формате
word7 = b'attribute'
word8 = b'класс'
word9 = b'функция'
word10 = b'type'

# выводим типы, содержимое и длину переменных
print(type(word7), word7)
print(type(word8), word8)
print(type(word9), word9)
print(type(word10), word10)

# Результат выполнения команд:

# Слова на кириллице невозможно записать в байтовом типе

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# Задание 4
# Преобразовать слова «разработка», «администрирование», «protocol», «standard» из
# строкового представления в байтовое и выполнить обратное преобразование (используя
# методы encode и decode)

word_list = ["разработка", "администрирование", "protocol", "standard"]

byte_list = []

for word in word_list:
    byte_word = word.encode("utf-8")
    byte_list.append(byte_word)
    print(f"{word} в байтовом представлении: {byte_word}")

decoded_list = []

for byte_word in byte_list:
    decoded_word = byte_word.decode("utf-8")
    decoded_list.append(decoded_word)
    print(f"{byte_word} в строковом представлении: {decoded_word}")

# Результат выполнения команд:

# разработка в байтовом представлении: b'\xd1\x80\xd0\xb0\xd0\xb7\xd1\x80\xd0\xb0\xd0\xb1\xd0\xbe\xd1\x82\xd0\xba\xd0\xb0'
# администрирование в байтовом представлении: b'\xd0\xb0\xd0\xb4\xd0\xbc\xd0\xb8\xd0\xbd\xd0\xb8\xd1\x81\xd1\x82\xd1\x80\xd0\xb8\xd1\x80\xd0\xbe\xd0\xb2\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xb5'
# protocol в байтовом представлении: b'protocol'
# standard в байтовом представлении: b'standard'
# b'\xd1\x80\xd0\xb0\xd0\xb7\xd1\x80\xd0\xb0\xd0\xb1\xd0\xbe\xd1\x82\xd0\xba\xd0\xb0' в строковом представлении: разработка
# b'\xd0\xb0\xd0\xb4\xd0\xbc\xd0\xb8\xd0\xbd\xd0\xb8\xd1\x81\xd1\x82\xd1\x80\xd0\xb8\xd1\x80\xd0\xbe\xd0\xb2\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xb5' в строковом представлении: администрирование
# b'protocol' в строковом представлении: protocol
# b'standard' в строковом представлении: standard

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# Задание 5
# Выполнить пинг веб-ресурсов yandex.ru, youtube.com и преобразовать результаты из
# байтовового в строковый тип на кириллице

import subprocess

# определяем список ресурсов для пинга
args1 = ['ping', 'yandex.ru']
args2 = ['ping', 'youtube.com']

# выполняем пинг каждого ресурса и преобразуем результат в строку на кириллице
subproc_ping = subprocess.Popen(args1, stdout=subprocess.PIPE)
for line in subproc_ping.stdout:
    line = line.decode('cp866').encode('utf-8')
    print(line.decode('utf-8'))

# Результат выполнения команд:
# Обмен пакетами с yandex.ru [5.255.255.77] с 32 байтами данных:
# Ответ от 5.255.255.77: число байт=32 время=8мс TTL=53
# Ответ от 5.255.255.77: число байт=32 время=10мс TTL=53
# Ответ от 5.255.255.77: число байт=32 время=9мс TTL=53
# Ответ от 5.255.255.77: число байт=32 время=8мс TTL=53
# Статистика Ping для 5.255.255.77:
#    Пакетов: отправлено = 4, получено = 4, потеряно = 0
#    (0% потерь)
# Приблизительное время приема-передачи в мс:
#    Минимальное = 8мсек, Максимальное = 10 мсек, Среднее = 8 мсек


# Обмен пакетами с youtube.com [209.85.233.91] с 32 байтами данных:
# Ответ от 209.85.233.91: число байт=32 время=24мс TTL=58
# Ответ от 209.85.233.91: число байт=32 время=24мс TTL=58
# Ответ от 209.85.233.91: число байт=32 время=24мс TTL=58
# Ответ от 209.85.233.91: число байт=32 время=24мс TTL=58
# Статистика Ping для 209.85.233.91:
#     Пакетов: отправлено = 4, получено = 4, потеряно = 0
#     (0% потерь)
# Приблизительное время приема-передачи в мс:
#     Минимальное = 24мсек, Максимальное = 24 мсек, Среднее = 24 мсек

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# Задание 6
# Создать текстовый файл test_file.txt, заполнить его тремя строками: «сетевое
# программирование», «сокет», «декоратор». Проверить кодировку файла по умолчанию.
# Принудительно открыть файл в формате Unicode и вывести его содержимое.

f_n = open('test_file.txt', 'w')
f_n.write('сетевое программирование\n')
f_n.write('сокет\n')
f_n.write('декоратор')
f_n.close()
print(f_n)


# Результат выполнения команд:
# <_io.TextIOWrapper name='test_file.txt' mode='w' encoding='cp1251'>

with open('test_file.txt', 'r', encoding='utf-8') as f:
    for line in f:
        print(line)

# Traceback (most recent call last):
#   File "D:\projects\pythonProject\11.py", line 10, in <module>
#     for line in f:
#   File "<frozen codecs>", line 322, in decode
# UnicodeDecodeError: 'utf-8' codec can't decode byte 0xf1 in position 0: invalid continuation byte